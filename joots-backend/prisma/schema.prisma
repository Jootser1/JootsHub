generator client {
  provider = "prisma-client-js"
}

generator seed {
  provider = "ts-node"
  output = "./prisma/seed.ts"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Auth {
  auth_id       String   @id @default(cuid())
  email         String   @unique
  password      String
  access_token  String?
  refresh_token String?
  created_at    DateTime @default(now())
  updated_at    DateTime @updatedAt
  user_id       String   @unique
  user          User     @relation(fields: [user_id], references: [user_id])
}

model User {
  user_id                   String                    @id @default(cuid())
  created_at                DateTime                  @default(now())
  username                  String                    @unique
  user_number               Int                       @unique @default(autoincrement())
  avatar                    String?
  updated_at                DateTime                  @default(now()) @updatedAt
  last_seen                 DateTime                  @default(now())
  role                      UserRole                  @default(USER)
  auth                      Auth?
  conversations             ConversationParticipant[]
  sent_messages             Message[]                 @relation("SentMessages")
  created_polls             Poll[]
  answers                   PollAnswer[]
  contact_of                UserContact[]             @relation("ContactOf")
  contacts                  UserContact[]             @relation("UserContacts")
  user_attributes           UserAttribute[]
  user_settings             UserSettings?
  user_category_preferences UserCategoryPreference[]
}

model UserAttribute {
  user_attribute_id String       @id @default(cuid())
  created_at        DateTime     @default(now())
  updated_at        DateTime     @updatedAt
  user_id           String
  user              User         @relation(fields: [user_id], references: [user_id])
  key               AttributeKey
  value             String
  level_revealed    Int

  @@unique([user_id, key])
  @@index([user_id])
}

model UserSettings {
  user_settings_id      String                   @id @default(cuid())
  user_id               String                   @unique
  user                  User                     @relation(fields: [user_id], references: [user_id])
  app_language          String                   @default("fr_FR")
  category_preferences  UserCategoryPreference[]
  accepted_languages    String[]                 @default(["fr_FR"])
  is_available_for_chat Boolean                  @default(true)
  updated_at            DateTime                 @default(now())
}

model UserContact {
  user_id    String
  contact_id String
  created_at DateTime @default(now())
  contact    User     @relation("ContactOf", fields: [contact_id], references: [user_id], onDelete: Cascade)
  user       User     @relation("UserContacts", fields: [user_id], references: [user_id], onDelete: Cascade)

  @@id([user_id, contact_id])
  @@index([user_id])
  @@index([contact_id])
}

model Conversation {
  conversation_id String                    @id @default(uuid())
  created_at      DateTime                  @default(now())
  updated_at      DateTime                  @updatedAt
  locale          LocaleCode                @default(fr_FR)
  xp_point        Int                       @default(0)
  difficulty      Difficulty                @default(INTERMEDIATE)
  participants    ConversationParticipant[]
  messages        Message[]
  sourceOf        PollAnswerSource[]
  current_poll_id String?
  current_poll    Poll?                     @relation(fields: [current_poll_id], references: [poll_id])
}

model ConversationParticipant {
  conversation_id     String
  user_id             String
  has_given_answer    Boolean      @default(false)
  is_icebreaker_ready Boolean      @default(false)
  conversation        Conversation @relation(fields: [conversation_id], references: [conversation_id])
  user                User         @relation(fields: [user_id], references: [user_id])

  @@id([conversation_id, user_id])
  @@unique([conversation_id, user_id])
}

model Message {
  message_id      String       @id @default(uuid())
  sender_id       String
  content         String
  created_at      DateTime     @default(now())
  conversation_id String
  status          MessageStatus
  conversation    Conversation @relation(fields: [conversation_id], references: [conversation_id])
  sender          User        @relation("SentMessages", fields: [sender_id], references: [user_id])

  @@index([conversation_id])
  @@index([sender_id])
}

enum PollType {
  OPEN
  MULTIPLE_CHOICE
  CONTINUOUS
  STEP_SCALE
  STEP_LABELED
  YES_NO_IDK
}

model Poll {
  poll_id           String               @id @default(cuid())
  type              PollType
  created_at        DateTime             @default(now())
  updated_at        DateTime             @updatedAt
  is_moderated      Boolean              @default(false)
  is_pinned         Boolean              @default(false)
  is_enabled        Boolean              @default(true)
  author_id         String
  author            User                 @relation(fields: [author_id], references: [user_id])
  poll_translations PollTranslation[]
  categories        PollCategory[]
  options           PollOption[]
  answers           PollAnswer[]
  scale_constraint  PollScaleConstraint?
  Conversation      Conversation[]
}

model Category {
  category_id      Int                      @id
  name             String                   @unique
  polls            PollCategory[]
  user_preferences UserCategoryPreference[]
}

model PollCategory {
  poll_id     String
  category_id Int
  poll        Poll     @relation(fields: [poll_id], references: [poll_id], onDelete: Cascade)
  category    Category @relation(fields: [category_id], references: [category_id], onDelete: Cascade)

  @@id([poll_id, category_id])
  @@index([poll_id])
  @@index([category_id])
}

model PollTranslation {
  poll_translation_id String     @id @default(uuid())
  translation         String
  locale              LocaleCode @default(fr_FR)
  poll_id             String
  poll                Poll       @relation(fields: [poll_id], references: [poll_id])

  @@unique([poll_id, locale])
}

model PollOption {
  poll_option_id String                  @id @default(cuid())
  poll_id        String
  order          Int
  poll           Poll                    @relation(fields: [poll_id], references: [poll_id])
  translations   PollOptionTranslation[]
  answers        PollAnswer[]
  histories      PollAnswerHistory[]
}

model PollOptionTranslation {
  id                     String @id @default(cuid())
  option_id              String
  locale                 String
  translated_option_text String

  option PollOption @relation(fields: [option_id], references: [poll_option_id])

  @@unique([option_id, locale])
}

model PollScaleConstraint {
  poll_id    String  @id @default(uuid())
  is_labeled Boolean @default(false)
  min_value  Int
  max_value  Int
  step_value Int?
  min_label  String?
  max_label  String?
  mid_label  String?

  poll Poll @relation(fields: [poll_id], references: [poll_id])
}

model PollAnswer {
  poll_answer_id String   @id @default(cuid())
  poll_id        String
  user_id        String?
  source_id      String?  @unique
  poll_option_id String?
  opentext       String?
  numeric        Float?
  answered_at    DateTime @default(now())
  comment        String?
  is_flagged     Boolean  @default(false)

  poll      Poll                @relation(fields: [poll_id], references: [poll_id])
  option    PollOption?         @relation(fields: [poll_option_id], references: [poll_option_id])
  source    PollAnswerSource?   @relation(fields: [source_id], references: [source_id])
  user      User?               @relation(fields: [user_id], references: [user_id], onDelete: Cascade)
  histories PollAnswerHistory[]

  @@unique([poll_id, user_id])
  @@index([user_id])
  @@index([poll_id])
}

enum AnswerSourceType {
  SOCIOSCOPY
  CONVERSATION
}

model PollAnswerSource {
  source_id       String           @id @default(cuid())
  source_type     AnswerSourceType
  locale          LocaleCode
  conversation_id String?

  answer       PollAnswer?
  conversation Conversation?       @relation(fields: [conversation_id], references: [conversation_id])
  history      PollAnswerHistory[]
}

model UserCategoryPreference {
  user_id          String
  category_id      Int
  opinion          Opinion       @default(NEUTRAL)
  created_at       DateTime      @default(now())
  updated_at       DateTime      @updatedAt
  category         Category      @relation(fields: [category_id], references: [category_id], onDelete: Cascade)
  user             User          @relation(fields: [user_id], references: [user_id], onDelete: Cascade)
  user_settings    UserSettings? @relation(fields: [user_settings_id], references: [user_settings_id])
  user_settings_id String?

  @@id([user_id, category_id])
  @@index([category_id])
  @@index([user_id])
}

model PollAnswerHistory {
  history_id     String   @id @default(uuid())
  poll_answer_id String
  poll_option_id String
  answered_at    DateTime @default(now())
  note           String?
  is_flagged     Boolean  @default(false)
  source_id      String

  history_source PollAnswerSource @relation(fields: [source_id], references: [source_id])
  poll_option    PollOption       @relation(fields: [poll_option_id], references: [poll_option_id], onDelete: Cascade)
  poll_answer    PollAnswer       @relation(fields: [poll_answer_id], references: [poll_answer_id], onDelete: Cascade)

  @@index([poll_answer_id])
  @@index([poll_option_id])
}

enum UserRole {
  USER
  LISTENER
}

enum LocaleCode {
  fr_FR
  en_US
  es_ES
}

enum MessageType {
  TEXT
  ANSWER
}

enum MessageStatus {
  SENT
  DELETED
  DELIVERED
  READ
}

enum Difficulty {
  EASY
  INTERMEDIATE
  HARDCORE
}

enum Opinion {
  DISLIKE
  NEUTRAL
  LIKE
}

enum AttributeKey {
  CITY
  AGE
  GENDER
  JOB
  ORIGIN
  ORIENTATION
  PASSIONS
  QUALITY
  FLAW
  BIO
}
