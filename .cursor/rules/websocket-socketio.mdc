# RÃ¨gles WebSocket & Socket.IO - JootsHub

## ðŸ—ï¸ Architecture Socket.IO

### Namespaces StandardisÃ©s
- **`/user`** : Gestion des statuts utilisateur, contacts, notifications
- **`/chat`** : Messages, conversations, icebreakers, typing
- **Pas de namespace par dÃ©faut** : Toujours utiliser des namespaces explicites

### Structure des Fichiers
```typescript
// Backend
src/gateways/
  base.gateway.ts           // Authentification commune
  user.gateway.ts           // Namespace /user
  chat.gateway.ts           // Namespace /chat

// Frontend  
src/features/[domain]/sockets/
  [domain]SocketService.ts  // Service de connexion
  [domain]EventHandlers.ts  // Handlers d'Ã©vÃ©nements
  [domain]EventRegistry.ts  // Registry des Ã©vÃ©nements
```

## ðŸ” Authentification WebSocket

### RÃ¨gles d'Authentification
```typescript
// âœ… BON - BaseGateway avec middleware commun
export abstract class BaseGateway implements OnGatewayConnection, OnGatewayDisconnect {
  afterInit(server: Server) {
    server.use(async (socket, next) => {
      try {
        const token = socket.handshake.auth.token
        const userId = socket.handshake.auth.userId
        
        if (!token || !userId) {
          return next(new Error('Authentification requise'))
        }
        
        const validUserId = this.extractUserIdFromToken(token)
        if (!validUserId || validUserId !== userId) {
          return next(new Error('Token invalide'))
        }
        
        socket.data.userId = userId
        next()
      } catch (error) {
        next(new Error('Erreur d\'authentification'))
      }
    })
  }
}

// âŒ MAUVAIS - Authentification dans chaque gateway
@SubscribeMessage('someEvent')
async handleEvent(@ConnectedSocket() client: Socket) {
  const token = client.handshake.auth.token // RÃ©pÃ©tition
  // Validation rÃ©pÃ©tÃ©e...
}
```

### CÃ´tÃ© Frontend - Authentification
```typescript
// âœ… BON - Credentials centralisÃ©s
class SocketManager {
  private credentials: { userId: string; token: string } | null = null
  
  setCredentials(userId: string, token: string) {
    this.credentials = { userId, token }
  }
  
  private getAuthConfig() {
    if (!this.credentials) throw new Error('Credentials manquants')
    
    return {
      auth: {
        token: this.credentials.token,
        userId: this.credentials.userId
      }
    }
  }
}
```

## ðŸ“¡ Nommage des Ã‰vÃ©nements

### Convention de Nommage
- **camelCase** pour tous les Ã©vÃ©nements
- **Verbes d'action** : `sendMessage`, `joinConversation`, `updateStatus`
- **Ã‰vÃ©nements de rÃ©ponse** : suffixe avec le statut (`messageReceived`, `statusUpdated`)

### Ã‰vÃ©nements StandardisÃ©s

#### Namespace `/chat`
```typescript
// âœ… Ã‰vÃ©nements entrants (client â†’ serveur)
interface ChatIncomingEvents {
  sendMessage: (data: SendMessageData) => void
  joinConversation: (data: JoinConversationData) => void
  leaveConversation: (data: LeaveConversationData) => void
  typing: (data: TypingData) => void
  icebreakerReady: (data: IcebreakerReadyData) => void
}

// âœ… Ã‰vÃ©nements sortants (serveur â†’ client)
interface ChatOutgoingEvents {
  newMessage: (data: NewMessageEvent) => void
  typing: (data: TypingEvent) => void
  icebreakerStatusUpdated: (data: IcebreakerStatusEvent) => void
  icebreakerQuestionGroup: (data: IcebreakerQuestionGroupEvent) => void
  icebreakerResponses: (data: IcebreakerResponsesEvent) => void
}
```

#### Namespace `/user`
```typescript
// âœ… Ã‰vÃ©nements entrants
interface UserIncomingEvents {
  updateUserStatus: (data: UpdateUserStatusData) => void
  joinContactsRooms: (data: JoinContactsRoomsData) => void
  leaveContactsRooms: (data: LeaveContactsRoomsData) => void
  pong: () => void
}

// âœ… Ã‰vÃ©nements sortants  
interface UserOutgoingEvents {
  userStatusChange: (data: UserStatusChangeEvent) => void
  ping: () => void
}
```

## ðŸŽ¯ Validation des Payloads

### Validation CÃ´tÃ© Backend
```typescript
// âœ… BON - DTOs avec class-validator
export class SendMessageDto {
  @IsString()
  @IsNotEmpty()
  conversationId: string

  @IsString()
  @IsNotEmpty()
  @MaxLength(1000)
  content: string

  @IsString()
  @IsNotEmpty()
  userId: string
}

@SubscribeMessage('sendMessage')
async handleSendMessage(
  @ConnectedSocket() client: Socket,
  @MessageBody() data: SendMessageDto // Validation automatique
) {
  // VÃ©rification d'autorisation
  if (data.userId !== client.data.userId) {
    throw new WsException('Non autorisÃ©')
  }
  
  // Logique mÃ©tier...
}
```

### Validation CÃ´tÃ© Frontend
```typescript
// âœ… BON - Schemas Zod pour validation
import { z } from 'zod'

const sendMessageSchema = z.object({
  conversationId: z.string().uuid(),
  content: z.string().min(1).max(1000),
  userId: z.string().uuid()
})

export class ChatSocketService {
  sendMessage(conversationId: string, content: string, userId: string) {
    // Validation avant envoi
    const data = sendMessageSchema.parse({
      conversationId,
      content, 
      userId
    })
    
    this.socket.emit('sendMessage', data)
  }
}
```

## ðŸ”„ Gestion des Connexions

### Pattern de Connexion/DÃ©connexion
```typescript
// âœ… BON - Tracking des connexions
export class ChatGateway extends BaseGateway {
  // Maps pour tracking
  private userChatSockets = new Map<string, string>() // userId â†’ socketId
  private chatSocketUsers = new Map<string, string>() // socketId â†’ userId
  
  async handleConnection(client: Socket) {
    const userId = client.data.userId
    
    if (!userId) {
      this.logger.warn(`Connexion rejetÃ©e sans ID utilisateur`)
      client.disconnect()
      return
    }
    
    // Enregistrement
    this.userChatSockets.set(userId, client.id)
    this.chatSocketUsers.set(client.id, userId)
    
    // Logique mÃ©tier (rejoindre conversations, etc.)
    await this.joinUserConversations(client, userId)
  }
  
  async handleDisconnect(client: Socket) {
    const userId = client.data.userId
    if (!userId) return
    
    try {
      // Nettoyage des maps
      this.userChatSockets.delete(userId)
      this.chatSocketUsers.delete(client.id)
      
      // Nettoyage mÃ©tier (quitter rooms, reset statuts)
      await this.cleanupUserSessions(client, userId)
      
    } catch (error) {
      this.logger.error(`Erreur dÃ©connexion: ${error.message}`)
    }
  }
}
```

### Gestion des Rooms
```typescript
// âœ… BON - Rooms par conversation
@SubscribeMessage('joinConversation')
handleJoinConversation(
  @ConnectedSocket() client: Socket,
  @MessageBody() data: { conversationId: string }
) {
  // VÃ©rification d'autorisation
  if (!this.canUserAccessConversation(client.data.userId, data.conversationId)) {
    throw new WsException('AccÃ¨s non autorisÃ© Ã  cette conversation')
  }
  
  client.join(data.conversationId)
  this.logger.debug(`${client.data.userId} a rejoint ${data.conversationId}`)
  
  return { success: true }
}

// âœ… BON - Rooms pour statuts utilisateur
private async joinContactStatusRooms(client: Socket, userId: string) {
  const contactIds = await this.getContactIds(userId)
  
  contactIds.forEach(contactId => {
    client.join(`user-status-${contactId}`)
  })
}
```

## ðŸš¨ Gestion d'Erreurs

### Exceptions WebSocket
```typescript
// âœ… BON - Toujours utiliser WsException
import { WsException } from '@nestjs/websockets'

@SubscribeMessage('someEvent')
async handleEvent(@MessageBody() data: any) {
  try {
    // Logique mÃ©tier
  } catch (error) {
    // âœ… BON - Exception WebSocket typÃ©e
    if (error instanceof ValidationError) {
      throw new WsException('DonnÃ©es invalides')
    }
    
    if (error instanceof UnauthorizedException) {
      throw new WsException('Non autorisÃ©')
    }
    
    // âœ… BON - Log + exception gÃ©nÃ©rique
    this.logger.error(`Erreur: ${error.message}`)
    throw new WsException('Erreur interne')
  }
}

// âŒ MAUVAIS - throw Error classique
throw new Error('Quelque chose a Ã©chouÃ©') // Ne sera pas bien gÃ©rÃ© cÃ´tÃ© client
```

### CÃ´tÃ© Frontend - Gestion d'Erreurs
```typescript
// âœ… BON - Handlers d'erreur centralisÃ©s
export class ChatSocketService {
  private setupErrorHandlers() {
    this.socket.on('connect_error', (error) => {
      logger.error('Erreur de connexion chat:', error)
      this.handleConnectionError(error)
    })
    
    this.socket.on('error', (error) => {
      logger.error('Erreur socket chat:', error)
      this.handleSocketError(error)
    })
  }
  
  private handleConnectionError(error: Error) {
    // Logique de reconnexion ou notification utilisateur
    if (error.message.includes('Authentification')) {
      // Rediriger vers login
      this.authService.logout()
    }
  }
}
```

## ðŸ”„ Reconnexion Automatique

### Configuration de Reconnexion
```typescript
// âœ… BON - Configuration robuste
const socketConfig = {
  autoConnect: false,
  reconnection: true,
  reconnectionAttempts: 5,
  reconnectionDelay: 1000,
  reconnectionDelayMax: 5000,
  timeout: 20000,
  forceNew: true
}

export class SocketService {
  private reconnectAttempts = 0
  private maxReconnectAttempts = 5
  
  private setupReconnectionHandlers() {
    this.socket.on('disconnect', (reason) => {
      logger.warn(`Socket dÃ©connectÃ©: ${reason}`)
      
      if (reason === 'io server disconnect') {
        // Reconnexion manuelle nÃ©cessaire
        this.scheduleReconnection()
      }
    })
    
    this.socket.on('reconnect', (attemptNumber) => {
      logger.info(`Socket reconnectÃ© aprÃ¨s ${attemptNumber} tentatives`)
      this.reconnectAttempts = 0
      this.onReconnected()
    })
  }
  
  private async onReconnected() {
    // Resynchroniser l'Ã©tat
    await this.rejoinAllRooms()
    await this.syncUserState()
  }
}
```

## ðŸ“Š Rate Limiting

### Limitation des Ã‰vÃ©nements
```typescript
// âœ… BON - Rate limiting par utilisateur
import { ThrottlerGuard } from '@nestjs/throttler'

@UseGuards(ThrottlerGuard)
@SubscribeMessage('sendMessage')
async handleSendMessage(/* ... */) {
  // LimitÃ© automatiquement par ThrottlerGuard
}

// âœ… BON - Rate limiting personnalisÃ©
private messageRateLimiter = new Map<string, number[]>()

@SubscribeMessage('sendMessage')
async handleSendMessage(@ConnectedSocket() client: Socket, @MessageBody() data: any) {
  const userId = client.data.userId
  const now = Date.now()
  const userMessages = this.messageRateLimiter.get(userId) || []
  
  // Nettoyer les anciens messages (> 1 minute)
  const recentMessages = userMessages.filter(time => now - time < 60000)
  
  if (recentMessages.length >= 30) { // Max 30 messages/minute
    throw new WsException('Trop de messages envoyÃ©s')
  }
  
  recentMessages.push(now)
  this.messageRateLimiter.set(userId, recentMessages)
  
  // Traiter le message...
}
```

## ðŸ§ª Tests WebSocket

### Tests d'IntÃ©gration
```typescript
// âœ… BON - Tests avec client Socket.IO
describe('ChatGateway', () => {
  let gateway: ChatGateway
  let client: Socket
  
  beforeEach(async () => {
    const module = await Test.createTestingModule({
      providers: [ChatGateway, /* ... */]
    }).compile()
    
    gateway = module.get<ChatGateway>(ChatGateway)
    
    // Client de test
    client = io('http://localhost:3001/chat', {
      auth: { token: 'valid-token', userId: 'user-123' }
    })
    
    await new Promise(resolve => client.on('connect', resolve))
  })
  
  it('should handle sendMessage event', (done) => {
    client.emit('sendMessage', {
      conversationId: 'conv-123',
      content: 'Hello',
      userId: 'user-123'
    })
    
    client.on('newMessage', (message) => {
      expect(message.content).toBe('Hello')
      done()
    })
  })
})
```

## ðŸ“‹ Checklist WebSocket

### âœ… **Avant chaque Ã©vÃ©nement :**
- [ ] Validation du payload avec DTO/Zod
- [ ] VÃ©rification d'autorisation (`userId === client.data.userId`)
- [ ] VÃ©rification d'accÃ¨s aux ressources (conversation, contact)
- [ ] Gestion d'erreurs avec `WsException`
- [ ] Logging appropriÃ©

### âœ… **Architecture :**
- [ ] Namespaces sÃ©parÃ©s par domaine
- [ ] BaseGateway pour authentification commune
- [ ] Event handlers sÃ©parÃ©s des gateways
- [ ] Maps de tracking des connexions
- [ ] Nettoyage appropriÃ© Ã  la dÃ©connexion

### âœ… **Performance :**
- [ ] Rate limiting sur Ã©vÃ©nements critiques
- [ ] Rooms optimisÃ©es (pas de broadcast global)
- [ ] Nettoyage des donnÃ©es temporaires
- [ ] Reconnexion automatique cÃ´tÃ© client

Cette structure garantit une architecture WebSocket robuste et maintenable pour JootsHub ! ðŸš€ 